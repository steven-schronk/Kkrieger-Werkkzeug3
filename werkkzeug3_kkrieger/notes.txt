Werkkzeug 3 & KKrieger Project Notes -------------------------------------

.k   files open with Werkkzeug. Contains graphics.
.kx  files open with the player executable. Contains graphics and sound.
.v2m files are midi music files.

Main window for Werkkzeug is in this class:
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\appbrowser.cpp

File selector class is:
sBrowserTree

Operators - Individual instructions for creating geometry, textures, etc.
struct KOp
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\kdoc.hpp

KOp represents the internal operation that is run to create the desired effect. KOps are found both on the player side and the Werkkzeug side.
WerkOp is only found in Werkkzeug and is a wrapper around the KOp that has additional parameters for the UI like, position, size, width, etc.

Ops can be linked in one of two ways. The most common would be to stack one operator on top of another. If a red line is drawn between them they are not compatible. The othe way to link them is using the parameter UI by choosing the Op to link. Using the parameter method the user has better contol over how they are linked together.

Geometry is created and modified in Werkkzeug using WerkOp objects.
These are a wrapper for the actual ops known as KOps.
WerkOps stores the position in the grid, width, name, etc.

KOps can have animation ops as well. Each time an Op is executed, a search is performed for potential animation ops:
WerkOpAnim *WinPara::FindOpAnim()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winpara.cpp

Werk Op Animation object is defined here:
class WerkOpAnim
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.hpp

Animation is performed by this call:
This is always called on each Op.  If there is no animation, the call returns.
Otherwise it continues to execute each animation instruction.
sInt KEnvironment::ExecuteAnim(struct KOp *op,sU8 *bytecode)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\kdoc.cpp

Animation Op codes are displayed in the top left of the animation page (window):
void WinAnimPage::OnPaint()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winpara.cpp

Each 2 or 4 character set of numbers represents a single Op.
The first two characters represent the Op itself.
The last two (if present) represent a parameter for the Op to work with.
The Op codes are listed here:
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\kdoc.hpp

When a demo is playing OnPaint is called for each frame, the WerkOps always starts from this root Op: root
void WinView::ShowDemo(sViewport &view,WerkOp *op,KEnvironment *kenv)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winview.cpp

DirectX Overlay - A dedicated area of video memory that can be overlayed on the primary surface
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\genoverlay.cpp

Windows Parameters - Sliders to change numerical values in Werkkzeug
class WinPara
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winpara.cpp

Virtual Machine - Stack & stack operations, execution code.
class sScriptVM
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\script.hpp

Bytecode For Virtual Machine
enum KBytecode2
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\script.hpp

Any time an Op in the editor is clicked this function is called:
void WinPara::SetOpNow(WerkOp *op)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winpara.cpp

Operators have three marks on the left side of their box in the UI:
Red   - Top Operator is selected
Black - Middle - Has been compiled in the past or has been selected in this session?
Green - Bottom Operator is compiled and running OK
Operators are colored based on their use. There are texture, materials, mesh, scene, screen operators.

When an operator's background turns red it indicates that something is wrong with the operator.
This happens when the operator above it is not compatible.

Some operators have a filmstrip on the right side that moves downward.
This indicates that this operator causes some form of animation.

Some operators do not have either an input or an output. If the input is not available, the top of the box will be clipped at an angle.
If output from the operator is not available, the bottom of the box will be clipped at an angle.

When the user clicks on a Cube operator this is called:
void Edit_Mesh_Cube(WerkkzeugApp *app,WerkOp *op)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkops.cpp

Each time a parameter for a cube us adjusted this is called:
GenMesh * __stdcall Mesh_Cube(sInt tx,sInt ty,sInt tz,sInt flags,sFSRT srt)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\genmesh.cpp

Called each time the window is painted:
void sGuiManager::OnPaint()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_gui.cpp

Paints (renders) the 3D window pane:
void WinView::OnPaint3d(sViewport &viewPort)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winview.cpp

Central point for handling different types of window actions:
sBool sAppHandler(sInt code,sDInt value)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug3\wz3_main.cpp

Glues everything together: logic, events, operators, splines, memory, time, camera
class KEnvironment;
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\kdoc.hpp

Drawing specific Ops in UI is handled by this class:
class WinView
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winview.cpp

Display texture bitmap in the UI:
void WinView::ShowBitmap(sViewport &view,class GenBitmap *tex)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winview.cpp

Displaying a mesh such as a cylindar, sphere, etc in the UI:
void WinView::ShowMesh(sViewport &view,GenMesh *mesh,KEnvironment *kenv)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winview.cpp

Displaying finished materials in the UI:
void WinView::ShowMaterial(sViewport &view,WerkOp *op,KEnvironment *kenv)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\winview.cpp

System configuration is stored in this global variable:
struct sSystem_
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.hpp

Logging - System has custom logging methods:
void __cdecl sDPrintF(const sChar *format,...)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_types.cpp

Application starts here.
int APIENTRY WinMain(HINSTANCE inst,HINSTANCE prev,LPSTR cmdline,int show)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

All opcodes used by a demo are listed here.
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\player_demo\demo_oplist.cpp
Note: These opcodes are listed in Hex but stored as a integer in the KOp and WerkOp classes.
This method can be used to decode an Op's type from a itself if getting to it's corresponding WerkOp is too difficult.
WerkClass *FindWerkClass(sInt id)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

Configuration file for Werkkzeug is loaded here:
sBool WerkkzeugApp::LoadConfig()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

Werkkzeug config file is located in the same folder as the .exe with file name werkkzeug.config.
The datatype for the file is sU32, so each entry is 32 bits.
It starts with this magic number: 0x3c3c3c3c
CID data is stored next.
Followed by version number and then size.
And ends with this magic number:  0x3e3e3e3e

Configuration settings for the tool get set here:
sBool WerkkzeugApp::LoadConfig()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

File for demo is opened here in player_intro:
sU8 *sSystem_::LoadFile(const sChar *name,sInt &size)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp
All data contained in file is cast to a sU8 datatype before writing to disk.

File for demo is opened here in werkkzeug3:
sU8 *sDiskItem::Load()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_diskitem.cpp

File is made of an array of this type:
typedef unsigned char sU8; /* 8 bits */

When a new project file is loaded the WerkkzeugApp class has to be cleared:
void WerkkzeugApp::Clear()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

The binary data from the (previously read) project file is loaded into the WerkDoc here:
sBool WerkDoc::Read(sU32 *&data)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

After all the WerkOps are setup they have to be connected together to form a tree:
void WerkDoc::Connect()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

Music for the project gets loaded here:
void WerkkzeugApp::MusicLoad()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

".k" file for demo is saved here:
sBool WerkkzeugApp::Write(sU32 *&data)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\werkkzeug.cpp

Opens up dialog box that asks for resolution, vsync, fullscreen, etc
sBool ConfigDialog(sInt nr,const sChar *title)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

DirectX libraries are loaded here:
void sSystem_::InitX()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

Initialize Direct Sound:
sBool sSystem_::InitDS()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

Virtual machine written in assembly language for sound generation:
Originally written for NASM assembler.
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_viruz2a.asm

Debug build uses nasm.exe which is a 16bit DOS executable.
Release build uses nasmw.exe which is a 32bit Windows console executable.
NASM uses a variant of Intel assembly syntax instead of AT&T syntax.

Start DemoScene - Main Loop
DXDev->BeginScene()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

Start DirectX Screens
void sSystem_::InitScreens()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

Create Buffers For Geometry (Vertices)
One is a Vertex Buffer The Other Is An Index Buffer
void sSystem_::CreateGeoBuffer(sInt i,sInt dyn,sInt index,sInt size)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

Geometry is loaded into the video card here:
sInt sSystem_::GeoAdd(sInt fvf,sInt prim)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

Size of buffers is hard set to large number.
#define MAX_DYNVBSIZE (64*0x8000)   /*    65,535 */
#define MAX_DYNIBSIZE (3*2*0x40000) /* 1,572,864 */

Starting DirectSound - Sample Format - starts thread for sound
sBool sSystem_::InitDS()
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

Load Textures Into DirectX
sInt sSystem_::AddTexture(sInt xs,sInt ys,sInt format,sU16 *data,sInt mipcount,sInt miptresh)
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp

When creating a new scene, the order that things are created matters:
Start with 2D Texture operators to create a new texture.
Combine the textures into a Material operator which define how the textures and light are combined and how the model is shaded.
Add meshes second. A mesh is a group of verticies defined using mesh operators. This defines verticies, edges and faces. Materials can be applied to a mesh.
Multiple scenes are combined on the timeline 
Many meshes are combined into a Scene.
Then next are the camera operators.

The camera operator specifies from how the user views the scene.

The Timeline is just a different way of viweing the Time operators. Time metrics are 256 Fractions make up a Beat and 4 Beats make up a Bar. During the specified time range, everything above the Time Pperator is rendered. At the same time there is a channel 0 variable that moves from 0 to 1 during the timespan. The 0 channel can be applied to any axis, multipled by a specified value, and a start value can be applied. You can select different types of movement like linear, sine, triangle, ramp, rectangular movement, and others from the dropdown.

There are 255 different chanels that can be used in total.

Time operators can be placed almost anywhere on the Pages.

-------

player_intro will open up and play a file only if you turn on compatibility with Windows 98.
Only seems to work with debris_chaos.kx and intro.kx files.

player_intro.exe C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\data\debris_chaos.kx
player_intro.exe C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\data\intro.kx

Keep default options. Wait until the progress bar has completed, then press the spacebar.

-------

Compilation Notes:

/01 	Minimal Size
/GY[-]  Function level linking (only links in functions that are needed).

------

The build contains a forced Header file that is the System Configuration file.

C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\player_intro\intro_config.hpp

------

I noticed something unusual in the code at this location:
C:\Users\eclipse\source\repos\Kkrieger-Werkkzeug3\werkkzeug3_kkrieger\_start.cpp:1706

#pragma lekktor(on)

Everything after that is grayed out as though it is not part of the build. Couldn't figure out how the data from the .kx file makes it into player_intro.exe program.
Turns out lekktor is a misspelled German word for lektor. (Remember they add an extra 'k' to the names of things.) That word means lecturer which translates into techspeak as logger.

When you turn that off, you can debug those lines after a rebuild.

------

When reading the binary data from a project file some bit shift magic is happening:

sInt inline OPC_GETDATA(sU32 x)   {return (x&0x000000ff);}
sInt inline OPC_GETINPUT(sU32 x)  {return (x&0x00000f00)>>8;}
sInt inline OPC_GETLINK(sU32 x)   {return (x&0x0000f000)>>12;}
sInt inline OPC_GETSTRING(sU32 x) {return (x&0x00070000)>>16;}
sInt inline OPC_GETSPLINE(sU32 x) {return (x&0x00700000)>>20;}

sU32 *&data

/* get a blob of data from a file */

data += OPC_GETDATA(conv);

------

Reading sections of an sF32 (float type):

void sVector::Read(sU32 *&p)
{
  x = ((sF32 *)p)[0];  // x, y, z, w is a float
  y = ((sF32 *)p)[1];
  z = ((sF32 *)p)[2];
  w = ((sF32 *)p)[3];
  p+=4;
}

------

Double right clicking an object in the 3Dviewer shows the geometry in wireframe.

----

Lekktor from the German word “Lektor” which means editor, as in person who edits books, not text editor. Takes the kkrieger_player program and instruments it with detailed code coverage tracking. In a second pass, it would take the code coverage information gathered in the first pass and eliminate all the paths that were never taken. Since all the content generation is deterministic and happens at the start of the program, you’d just need to launch the game once in instrumented mode, take the dumped coverage information, then run Lekktor again to write the “dead-stripped” source files and recompile.

Removes any branches in the code that are not taken during the run. This would normally not be done in production software, but in sizecoding the goal is to produce the smallest executeable possible.

----

Order Of Execution For Annotated Intro Scene

KObject::KObject()
DirectMaterial: sources not found
KObject::KObject()
Create Rendertarget 16x16
KObject::KObject()
Create Rendertarget 16x16
KObject::KObject()
Create Rendertarget 16x16
KObject::KObject()
Create Rendertarget 512x256
KObject::KObject()
Create Rendertarget 512x256
KObject::KObject()
Create Rendertarget 512x256
KObject::KObject()
Create Rendertarget 16x16
KObject::KObject()
Create Rendertarget 16x16
KObject::KObject()
Create Rendertarget 16x16
KObject::KObject()
Create Rendertarget 1024x512
KObject::KObject()
Create Rendertarget 1024x512
KObject::KObject()
Create Rendertarget 1024x512
Create Texture 4x4
Create Texture 4x4
MemManagerInit()
KMemoryManager_::KMemoryManager_()
KMemoryManager_::SetBudget(sInt 1,sInt 201326592)
KMemoryManager_::SetBudget(sInt 6,sInt 100663296)
Create Rendertarget 2048x1024
Create ZBuffer 2048x1024
Create Texture 32x32
Create Texture 128x128
Create Texture 256x128
Create Texture 256x128
Create Texture 256x128
Create Texture 256x128
Create Texture 256x128
Create Texture 256x128
KEvent::Init()
KObject::KObject()
KObject::KObject()
Create Texture 16x16
Create Texture 16x16
Create Texture 16x16
Create Texture 16x16
KObject::KObject()
KObject::KObject()
sBrowserApp::sBrowserApp()
sBrowserTree()
KEnvironment()
KEnvironment::InitFrame(sInt  1693232, sInt  1693236)
*** Loading <werkkzeug.config> (332 bytes)
KMemoryManager_::SetBudget(sInt 1,sInt 201326592)
KMemoryManager_::SetBudget(sInt 6,sInt 100663296)sImplementFileMenu(sU32 cmd...
*** Loading <c:/Users/eclipse/source/repos/Kkrieger-Werkkzeug3/werkkzeug3_kkrieger/data/intro_annotated2.k> (9196 bytes)
KOp::Init(sU32 100663309)
KOp::SetBlob(const sU8 00000000,sInt 0)
...
KEvent::Init()
KEvent::Init()
actual load done
KEnvironment::InitView()
KInstanceMem::DeleteChain()
KOp::Change(sInt -1)
...
KEnvironment::InitView()
KInstanceMem::DeleteChain()
*** Loading <simu3d.v2m> failed
KMemoryManager_::GetBudget(sInt 1)
KMemoryManager_::GetBudget(sInt 6)
*** Saving <werkkzeug.config> (332 bytes)
KMemoryManager_::Validate()
KEnvironment::InitFrame(sInt  1698064, sInt  1698068)
KEnvironment::AddStaticEvent(KEvent *event)
KInstanceMem::DeleteChain()
KEnvironment::AddStaticEvent(KEvent *event)
KEnvironment::ExitFrame()
...
WinPara::SetOp: Vroot
KMemoryManager_::Validate()
KEnvironment::InitFrame(sInt  1698064, sInt  1698068)
KEnvironment::AddStaticEvent(KEvent *event)
KEnvironment::AddStaticEvent(KEvent *event)
KEnvironment::ExitFrame()
WinPara::OnCommand: CMD_PARA_SETOP
WinPara::SetOpNow: Vroot
KMemoryManager_::Validate()
KEnvironment::InitFrame(sInt  1698064, sInt  1698068)
KEnvironment::AddStaticEvent(KEvent *event)
KEnvironment::AddStaticEvent(KEvent *event)
KEnvironment::ExitFrame()
WinAnimPage::OnPaint(): KA_END .
...
...
--------------------------------------------------------------------------------
...
...
WinAnimPage::OnPaint(): KA_END .								<- Start drawing new frame
KEnvironment::InitView()
KInstanceMem::DeleteChain()
KMemoryManager_::Validate()
KEnvironment::InitFrame(sInt  1698064, sInt  1698068)
KEnvironment::AddStaticEvent(KEvent *event)
KInstanceMem::DeleteChain()
KEnvironment::AddStaticEvent(KEvent *event)
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp Vroot, sU8 )				<- Vroot
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp UDemo, sU8 )				<- UDemo
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp event1, sU8 )				<- event1
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp , sU8 )
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp Sscene1, sU8 )				<- Sscene1
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp QViewport, sU8 )			<- QViewport 
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp NAdd, sU8 )				<- NAdd
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp JScene, sU8 )				<- JScene
Animation Ops: KA_LOADVAR KOp::UpdateVar(sInt 0,sInt 1)
KA_STOREPARAFLOAT KA_CHANGEPARAFLOAT KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp GMatLink, sU8 )			<- GMatLink 
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp DTourus, sU8 )				<- DTourus
Animation Ops: KA_END
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6566338,sInt *para,sInt 7)
KObject::KObject()
KEnvironment::Pop(sInt 0)
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp Pmat_cell, sU8 )			<- Pmap_cell 
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp Itex_cell, sU8 )			<- Itex_cell 
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp FText, sU8 )				<- FTex
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp CCell, sU8 )				<- CCell
Animation Ops: KA_END
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6560533,sInt *para,sInt 13)				<- Mystery call to ASM
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop 1
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6557588,sInt *para,sInt 14)
KObject::KObject()
KOp::SetBlob(const sU8 00000000,sInt 0)
KEnvironment::Pop(sInt 0)										<- Pop 2
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6565838,sInt *para,sInt 1)
KEnvironment::Pop(sInt 0)										<- Pop 3
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6567698,sInt *para,sInt 1)
Create Texture 512x512
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop 4
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6567813,sInt *para,sInt 4)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop 5
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6555568,sInt *para,sInt 11)
KObject::KObject()
KObject::KObject()
KObject::KObject()
KObject::KObject()
KObject::KObject()
KObject::KObject()
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop 6 (NAdd)
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp KLight, sU8 )				<- KLight
Animation Ops: KA_END
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6545918,sInt *para,sInt 11)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop 1 (NAdd)
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6552508,sInt *para,sInt 3)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop QViewport
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6553543,sInt *para,sInt 27)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop Sscene1
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6565838,sInt *para,sInt 1)
KEnvironment::Pop(sInt 0)										<- Pop Sscene1
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6550548,sInt *para,sInt 1)
KEnvironment::Pop(sInt 0)										<- Pop event1
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6553798,sInt *para,sInt 2)
KEnvironment::Pop(sInt 0)										<- Pop UDemo
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp event2, sU8 )				<- event2
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp , sU8 )					
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp Tscene2, sU8 )				<- Tscene2
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp RViewPort, sU8 )			<- RViewPort
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp OAdd, sU8 )				<- OAdd
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp LLight, sU8 )				<- LLight
Animation Ops: KA_LOADVAR KOp::UpdateVar(sInt 0,sInt 1)
KA_STOREPARAFLOAT KA_CHANGEPARAFLOAT KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp HMatlink, sU8 )			<- HMatLink
Animation Ops: KA_END
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp ECube, sU8 )				<- ECube
Animation Ops: KA_END
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6549038,sInt *para,sInt 13)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop ECube
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Calc(KEnvironment *env,sInt flags)
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6567813,sInt *para,sInt 4)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop HMatlink
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6555568,sInt *para,sInt 11)
KObject::KObject()
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop LLight
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Calc(KEnvironment *env,sInt flags)
KEnvironment::ExecuteAnim(struct KOp MLight, sU8 )				<- MLight
Animation Ops: KA_END
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6545918,sInt *para,sInt 11)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop MLight
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 0)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6552508,sInt *para,sInt 3)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop OAdd
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6553543,sInt *para,sInt 27)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop RViewPort
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6565838,sInt *para,sInt 1)
KEnvironment::Pop(sInt 0)										<- Pop Tscene2
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6550548,sInt *para,sInt 1)
KEnvironment::Pop(sInt 0)										<- Pop Tscene3
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6553798,sInt *para,sInt 2)
KEnvironment::Pop(sInt 0)										<- Pop event2
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6558908,sInt *para,sInt 1)
KObject::KObject()
KEnvironment::Pop(sInt 0)										<- Pop UDemo
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
KOp::UpdateVar(sInt 0,sInt 1)
KOp::Call(KEnvironment *kenv)
KDoc.cpp:CallCode(sInt 6565838,sInt *para,sInt 1)
KEnvironment::Pop(sInt 0)										<- Pop vroot
KMemoryManager_::Use(KOp *op)
sInt GetObjectSize(KObject *obj)
KMemoryManager_::Manage()
ShowDemo WerokOp = Vroot										<- ShowDemo
KOp::Exec(KEnvironment *kenv, Vroot)
KEnvironment::ExecuteAnim(struct KOp Vroot, sU8 )				<- Vroot
Animation Ops: KA_END
KOp::ExecInputs(KEnvironment *kenv)
KOp::Exec(KEnvironment *kenv, UDemo)
KEnvironment::ExecuteAnim(struct KOp UDemo, sU8 )				<- UDemo
Animation Ops: KA_END
Exec_Misc_Demo(KOp *op,KEnvironment *kenv)
KOp::ExecInput(KEnvironment *kenv,sInt 0)
KOp::Exec(KEnvironment *kenv, event1)
KEnvironment::ExecuteAnim(struct KOp event1, sU8 )				<- event1
Animation Ops: KA_END
KDoc.cpp:CallCode(sInt 6564228,sInt *para,sInt 3)
KOp::ExecEvent(KEnvironment *kenv,KEvent *event,sBool)
KOp::ExecWithNewMem(KEnvironment *kenv,KInstanceMem **link)
KOp::Exec(KEnvironment *kenv, )
KEnvironment::ExecuteAnim(struct KOp , sU8 )
Animation Ops: KA_END
KOp::Exec(KEnvironment *kenv, Sscene1)
KEnvironment::ExecuteAnim(struct KOp Sscene1, sU8 )				<- Sscene1
Animation Ops: KA_END
KOp::ExecInputs(KEnvironment *kenv)
KOp::Exec(KEnvironment *kenv, QViewport)
KEnvironment::ExecuteAnim(struct KOp QViewport, sU8 )			<- QViewport
Animation Ops: KA_END
KDoc.cpp:CallCode(sInt 6548853,sInt *para,sInt 27)
KOp::Exec(KEnvironment *kenv, NAdd)
KEnvironment::ExecuteAnim(struct KOp NAdd, sU8 )				<- NAdd
Animation Ops: KA_END
KOp::Exec(KEnvironment *kenv, JScene)
KEnvironment::ExecuteAnim(struct KOp JScene, sU8 )				<- JScene
Animation Ops: KA_LOADVAR KOp::UpdateVar(sInt 0,sInt 1)
KA_STOREPARAFLOAT KA_CHANGEPARAFLOAT KA_END
KDoc.cpp:CallCode(sInt 6565983,sInt *para,sInt 12)
KEnvironment::Pop(sInt 0)										<- POP JScene
KOp::Exec(KEnvironment *kenv, KLight)							<- KLight
KEnvironment::ExecuteAnim(struct KOp KLight, sU8 )				<- KLight
Animation Ops: KA_END
KDoc.cpp:CallCode(sInt 6556163,sInt *para,sInt 13)
KEnvironment::Pop(sInt 0)										<- POP NAdd
KEnvironment::Pop(sInt 0)										<- POP QViewport
Create static vertex-Buffer (2097152 bytes) id 4
Create static index-Buffer (1572864 bytes) id 5
KEnvironment::Pop(sInt 0)										<- POP Sscene1							
KEnvironment::Pop(sInt 0)										<- POP Sscene1
KEnvironment::Pop(sInt 0)										<- POP event1
KEnvironment::Pop(sInt 0)										<- POP UDemo
KOp::ExecInput(KEnvironment *kenv,sInt 1)
KOp::Exec(KEnvironment *kenv, event2)
KEnvironment::ExecuteAnim(struct KOp event2, sU8 )				<- event2
Animation Ops: KA_END
KDoc.cpp:CallCode(sInt 6564228,sInt *para,sInt 3)
KEnvironment::Pop(sInt 0)										<- POP event2
KEnvironment::Pop(sInt 0)										<- POP UDemo
KEnvironment::Pop(sInt 0)										<- POP Vroot
KEnvironment::ExitFrame()

Animation starts from the root node. Then moves up one KOp at a time following the leftmost path.
If the Op has an animation Op, execute those from the left to right column starting at the top and moving downward to the terminal Op. Then continue until the grid is complete.
Some Ops call out to other ops as a parameter. For example a MatLink Op has a parameter for Material. When this parameter is present, it calls the linked Op and continues to follow from there.
KDoc.cpp:CallCode(sInt 6560533,sInt *para,sInt 13)				<- Initialize or perform work that Op does
Create new KObject.
Update KOp variable. KOp::UpdateVar(sInt 0,sInt 0)
Call KOp object.
KDoc.cpp:CallCode(sInt 6560533,sInt *para,sInt 13)				<- Initialize or perform work that Op does
Create several new KObjects.
When the end of that branch of the tree is called, walk back down the tree to find an unexecuted branch. Follow that branch wherever it leads.

--------------------------------------------------------------------------------

Every WerkClass has a standard calling convention stored in an unsigned int.

Name         "Cylinder"
ID            0x82
Output        KC_MESH
MinInput      0
MaxInput      0
Convention    0x06000005
Column        COL_NEW
Shortcut      'z'
Packing       "bbbbb"      // sChar* "iiffbc" type information for packing
Edit Handler  Edit_Mesh_Cylinder
InitHandler   Mesh_Cylinder
ExecHandler   Exec_Misc_Nop
Inputs Array  { 0 }
Links Array   { 0 }

unsigned int Convention;                          // calling convention: 0xm00slipp (modify,0,strings,links,inputs,para)

sInt inline OPC_GETDATA(sU32 x)   {return (x&0x000000ff);}
sInt inline OPC_GETINPUT(sU32 x)  {return (x&0x00000f00)>>8;}
sInt inline OPC_GETLINK(sU32 x)   {return (x&0x0000f000)>>12;}
sInt inline OPC_GETSTRING(sU32 x) {return (x&0x00070000)>>16;}
sInt inline OPC_GETSPLINE(sU32 x) {return (x&0x00700000)>>20;} // i assume that 2 bit are enough, tho